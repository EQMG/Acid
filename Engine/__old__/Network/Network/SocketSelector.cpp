#include "SocketSelector.hpp"

#ifdef ACID_BUILD_WINDOWS
#include <WinSock2.h>
#else
#include <sys/types.h>
#include <unistd.h>
#endif

#include "Engine/Log.hpp"
#include "Socket.hpp"

#ifdef _MSC_VER
#pragma warning(disable: 4127) // "conditional expression is constant" generated by the FD_SET macro
#endif

namespace acid {
struct SocketSelector::SocketSelectorImpl {
	/// Set containing all the sockets handles.
	fd_set allSockets;
	/// Set containing handles of the sockets that are ready.
	fd_set socketsReady;
	/// Maximum socket handle.
	int maxSocket;
	/// Number of socket handles.
	int socketCount;
};

SocketSelector::SocketSelector() :
	impl(std::make_unique<SocketSelectorImpl>()) {
	Clear();
}

SocketSelector::SocketSelector(const SocketSelector &copy) :
	impl(std::make_unique<SocketSelectorImpl>(*copy.impl)) {
}

void SocketSelector::Add(Socket &socket) {
	auto handle = socket.GetHandle();

	if (handle != Socket::InvalidSocketHandle()) {
#ifdef ACID_BUILD_WINDOWS
		if (impl->socketCount >= FD_SETSIZE) {
			Log::Error("The socket can't be added to the selector because the selector is full. This is a limitation of your operating system's FD_SETSIZE setting.\n");
			return;
		}

		if (FD_ISSET(handle, &impl->allSockets))
			return;

		impl->socketCount++;
#else
		if (handle >= FD_SETSIZE) {
			Log::Error("The socket can't be added to the selector because its ID is too high. This is a limitation of your operating system's FD_SETSIZE setting.\n");
			return;
		}

		// SocketHandle is an int in POSIX
		impl->maxSocket = std::max(impl->maxSocket, handle);
#endif

		FD_SET(handle, &impl->allSockets);
	}
}

void SocketSelector::Remove(Socket &socket) {
	auto handle = socket.GetHandle();

	if (handle != Socket::InvalidSocketHandle()) {
#ifdef ACID_BUILD_WINDOWS
		if (!FD_ISSET(handle, &impl->allSockets))
			return;

		impl->socketCount--;

#else
		if (handle >= FD_SETSIZE)
			return;
#endif

		FD_CLR(handle, &impl->allSockets);
		FD_CLR(handle, &impl->socketsReady);
	}
}

void SocketSelector::Clear() {
	FD_ZERO(&impl->allSockets);
	FD_ZERO(&impl->socketsReady);

	impl->maxSocket = 0;
	impl->socketCount = 0;
}

bool SocketSelector::Wait(const Time timeout) {
	// Setup the timeout
	timeval time = {};
	time.tv_sec = static_cast<long>(timeout.AsMicroseconds() / 1000000);
	time.tv_usec = static_cast<long>(timeout.AsMicroseconds() % 1000000);

	// Initialize the set that will contain the sockets that are ready
	impl->socketsReady = impl->allSockets;

	// Wait until one of the sockets is ready for reading, or timeout is reached
	// The first parameter is ignored on Windows
	auto count = select(impl->maxSocket + 1, &impl->socketsReady, nullptr, nullptr, timeout != 0s ? &time : nullptr);

	return count > 0;
}

bool SocketSelector::IsReady(const Socket &socket) const {
	auto handle = socket.GetHandle();

	if (handle != Socket::InvalidSocketHandle()) {
#ifndef ACID_BUILD_WINDOWS
		if (handle >= FD_SETSIZE)
			return false;
#endif

		return FD_ISSET(handle, &impl->socketsReady) != 0;
	}

	return false;
}

SocketSelector &SocketSelector::operator=(const SocketSelector &right) {
	SocketSelector temp = right;
	impl.swap(temp.impl);
	return *this;
}
}
